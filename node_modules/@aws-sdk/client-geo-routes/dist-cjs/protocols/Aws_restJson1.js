"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.de_SnapToRoadsCommand = exports.de_OptimizeWaypointsCommand = exports.de_CalculateRoutesCommand = exports.de_CalculateRouteMatrixCommand = exports.de_CalculateIsolinesCommand = exports.se_SnapToRoadsCommand = exports.se_OptimizeWaypointsCommand = exports.se_CalculateRoutesCommand = exports.se_CalculateRouteMatrixCommand = exports.se_CalculateIsolinesCommand = void 0;
const core_1 = require("@aws-sdk/core");
const core_2 = require("@smithy/core");
const smithy_client_1 = require("@smithy/smithy-client");
const GeoRoutesServiceException_1 = require("../models/GeoRoutesServiceException");
const models_0_1 = require("../models/models_0");
const se_CalculateIsolinesCommand = async (input, context) => {
    const b = (0, core_2.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/isolines");
    const query = (0, smithy_client_1.map)({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Allow: (_) => (0, smithy_client_1._json)(_),
        ArrivalTime: [],
        Avoid: (_) => se_IsolineAvoidanceOptions(_, context),
        DepartNow: [],
        DepartureTime: [],
        Destination: (_) => se_Position(_, context),
        DestinationOptions: (_) => se_IsolineDestinationOptions(_, context),
        IsolineGeometryFormat: [],
        IsolineGranularity: (_) => (0, smithy_client_1._json)(_),
        OptimizeIsolineFor: [],
        OptimizeRoutingFor: [],
        Origin: (_) => se_Position(_, context),
        OriginOptions: (_) => se_IsolineOriginOptions(_, context),
        Thresholds: (_) => (0, smithy_client_1._json)(_),
        Traffic: (_) => (0, smithy_client_1._json)(_),
        TravelMode: [],
        TravelModeOptions: (_) => se_IsolineTravelModeOptions(_, context),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CalculateIsolinesCommand = se_CalculateIsolinesCommand;
const se_CalculateRouteMatrixCommand = async (input, context) => {
    const b = (0, core_2.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/route-matrix");
    const query = (0, smithy_client_1.map)({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Allow: (_) => (0, smithy_client_1._json)(_),
        Avoid: (_) => se_RouteMatrixAvoidanceOptions(_, context),
        DepartNow: [],
        DepartureTime: [],
        Destinations: (_) => se_RouteMatrixDestinationList(_, context),
        Exclude: (_) => (0, smithy_client_1._json)(_),
        OptimizeRoutingFor: [],
        Origins: (_) => se_RouteMatrixOriginList(_, context),
        RoutingBoundary: (_) => se_RouteMatrixBoundary(_, context),
        Traffic: (_) => (0, smithy_client_1._json)(_),
        TravelMode: [],
        TravelModeOptions: (_) => se_RouteMatrixTravelModeOptions(_, context),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CalculateRouteMatrixCommand = se_CalculateRouteMatrixCommand;
const se_CalculateRoutesCommand = async (input, context) => {
    const b = (0, core_2.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/routes");
    const query = (0, smithy_client_1.map)({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Allow: (_) => (0, smithy_client_1._json)(_),
        ArrivalTime: [],
        Avoid: (_) => se_RouteAvoidanceOptions(_, context),
        DepartNow: [],
        DepartureTime: [],
        Destination: (_) => se_Position(_, context),
        DestinationOptions: (_) => se_RouteDestinationOptions(_, context),
        Driver: (_) => (0, smithy_client_1._json)(_),
        Exclude: (_) => (0, smithy_client_1._json)(_),
        InstructionsMeasurementSystem: [],
        Languages: (_) => (0, smithy_client_1._json)(_),
        LegAdditionalFeatures: (_) => (0, smithy_client_1._json)(_),
        LegGeometryFormat: [],
        MaxAlternatives: [],
        OptimizeRoutingFor: [],
        Origin: (_) => se_Position(_, context),
        OriginOptions: (_) => se_RouteOriginOptions(_, context),
        SpanAdditionalFeatures: (_) => (0, smithy_client_1._json)(_),
        Tolls: (_) => (0, smithy_client_1._json)(_),
        Traffic: (_) => (0, smithy_client_1._json)(_),
        TravelMode: [],
        TravelModeOptions: (_) => se_RouteTravelModeOptions(_, context),
        TravelStepType: [],
        Waypoints: (_) => se_RouteWaypointList(_, context),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CalculateRoutesCommand = se_CalculateRoutesCommand;
const se_OptimizeWaypointsCommand = async (input, context) => {
    const b = (0, core_2.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/optimize-waypoints");
    const query = (0, smithy_client_1.map)({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        Avoid: (_) => se_WaypointOptimizationAvoidanceOptions(_, context),
        Clustering: (_) => (0, smithy_client_1._json)(_),
        DepartureTime: [],
        Destination: (_) => se_Position(_, context),
        DestinationOptions: (_) => se_WaypointOptimizationDestinationOptions(_, context),
        Driver: (_) => (0, smithy_client_1._json)(_),
        Exclude: (_) => (0, smithy_client_1._json)(_),
        OptimizeSequencingFor: [],
        Origin: (_) => se_Position(_, context),
        OriginOptions: (_) => (0, smithy_client_1._json)(_),
        Traffic: (_) => (0, smithy_client_1._json)(_),
        TravelMode: [],
        TravelModeOptions: (_) => se_WaypointOptimizationTravelModeOptions(_, context),
        Waypoints: (_) => se_WaypointOptimizationWaypointList(_, context),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_OptimizeWaypointsCommand = se_OptimizeWaypointsCommand;
const se_SnapToRoadsCommand = async (input, context) => {
    const b = (0, core_2.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/snap-to-roads");
    const query = (0, smithy_client_1.map)({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        SnapRadius: [],
        SnappedGeometryFormat: [],
        TracePoints: (_) => se_RoadSnapTracePointList(_, context),
        TravelMode: [],
        TravelModeOptions: (_) => (0, smithy_client_1._json)(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_SnapToRoadsCommand = se_SnapToRoadsCommand;
const de_CalculateIsolinesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await (0, core_1.parseJsonBody)(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ArrivalTime: smithy_client_1.expectString,
        DepartureTime: smithy_client_1.expectString,
        IsolineGeometryFormat: smithy_client_1.expectString,
        Isolines: (_) => de_IsolineList(_, context),
        SnappedDestination: (_) => de_Position(_, context),
        SnappedOrigin: (_) => de_Position(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CalculateIsolinesCommand = de_CalculateIsolinesCommand;
const de_CalculateRouteMatrixCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await (0, core_1.parseJsonBody)(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        ErrorCount: smithy_client_1.expectInt32,
        RouteMatrix: smithy_client_1._json,
        RoutingBoundary: (_) => de_RouteMatrixBoundary(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CalculateRouteMatrixCommand = de_CalculateRouteMatrixCommand;
const de_CalculateRoutesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await (0, core_1.parseJsonBody)(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        LegGeometryFormat: smithy_client_1.expectString,
        Notices: smithy_client_1._json,
        Routes: (_) => de_RouteList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CalculateRoutesCommand = de_CalculateRoutesCommand;
const de_OptimizeWaypointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await (0, core_1.parseJsonBody)(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Connections: smithy_client_1._json,
        Distance: smithy_client_1.expectLong,
        Duration: smithy_client_1.expectLong,
        ImpedingWaypoints: (_) => de_WaypointOptimizationImpedingWaypointList(_, context),
        OptimizedWaypoints: (_) => de_WaypointOptimizationOptimizedWaypointList(_, context),
        TimeBreakdown: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_OptimizeWaypointsCommand = de_OptimizeWaypointsCommand;
const de_SnapToRoadsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await (0, core_1.parseJsonBody)(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        Notices: smithy_client_1._json,
        SnappedGeometry: (_) => de_RoadSnapSnappedGeometry(_, context),
        SnappedGeometryFormat: smithy_client_1.expectString,
        SnappedTracePoints: (_) => de_RoadSnapSnappedTracePointList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_SnapToRoadsCommand = de_SnapToRoadsCommand;
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await (0, core_1.parseJsonErrorBody)(output.body, context),
    };
    const errorCode = (0, core_1.loadRestJsonErrorCode)(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.georoutes#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.georoutes#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.georoutes#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.georoutes#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(GeoRoutesServiceException_1.GeoRoutesServiceException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        Message: [, smithy_client_1.expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        FieldList: [, (_) => de_ValidationExceptionFieldList(_, context), `fieldList`],
        Message: [, smithy_client_1.expectString, `message`],
        Reason: [, smithy_client_1.expectString, `reason`],
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const se_BoundingBox = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.serializeFloat)(entry);
    });
};
const se_Circle = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Center: (_) => se_Position(_, context),
        Radius: smithy_client_1.serializeFloat,
    });
};
const se_Corridor = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        LineString: (_) => se_LineString(_, context),
        Radius: [],
    });
};
const se_IsolineAvoidanceArea = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Except: (_) => se_IsolineAvoidanceAreaGeometryList(_, context),
        Geometry: (_) => se_IsolineAvoidanceAreaGeometry(_, context),
    });
};
const se_IsolineAvoidanceAreaGeometry = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        BoundingBox: (_) => se_BoundingBox(_, context),
        Corridor: (_) => se_Corridor(_, context),
        Polygon: (_) => se_LinearRings(_, context),
        PolylineCorridor: smithy_client_1._json,
        PolylinePolygon: smithy_client_1._json,
    });
};
const se_IsolineAvoidanceAreaGeometryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_IsolineAvoidanceAreaGeometry(entry, context);
    });
};
const se_IsolineAvoidanceAreaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_IsolineAvoidanceArea(entry, context);
    });
};
const se_IsolineAvoidanceOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Areas: (_) => se_IsolineAvoidanceAreaList(_, context),
        CarShuttleTrains: [],
        ControlledAccessHighways: [],
        DirtRoads: [],
        Ferries: [],
        SeasonalClosure: [],
        TollRoads: [],
        TollTransponders: [],
        TruckRoadTypes: smithy_client_1._json,
        Tunnels: [],
        UTurns: [],
        ZoneCategories: smithy_client_1._json,
    });
};
const se_IsolineCarOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        EngineType: [],
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
    });
};
const se_IsolineDestinationOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AvoidActionsForDistance: [],
        Heading: smithy_client_1.serializeFloat,
        Matching: smithy_client_1._json,
        SideOfStreet: (_) => se_IsolineSideOfStreetOptions(_, context),
    });
};
const se_IsolineOriginOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AvoidActionsForDistance: [],
        Heading: smithy_client_1.serializeFloat,
        Matching: smithy_client_1._json,
        SideOfStreet: (_) => se_IsolineSideOfStreetOptions(_, context),
    });
};
const se_IsolineScooterOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        EngineType: [],
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
    });
};
const se_IsolineSideOfStreetOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Position: (_) => se_Position(_, context),
        UseWith: [],
    });
};
const se_IsolineTravelModeOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Car: (_) => se_IsolineCarOptions(_, context),
        Scooter: (_) => se_IsolineScooterOptions(_, context),
        Truck: (_) => se_IsolineTruckOptions(_, context),
    });
};
const se_IsolineTruckOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AxleCount: [],
        EngineType: [],
        GrossWeight: [],
        HazardousCargos: smithy_client_1._json,
        Height: [],
        HeightAboveFirstAxle: [],
        KpraLength: [],
        Length: [],
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
        PayloadCapacity: [],
        TireCount: [],
        Trailer: smithy_client_1._json,
        TruckType: [],
        TunnelRestrictionCode: [],
        WeightPerAxle: [],
        WeightPerAxleGroup: smithy_client_1._json,
        Width: [],
    });
};
const se_LinearRing = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Position(entry, context);
    });
};
const se_LinearRings = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_LinearRing(entry, context);
    });
};
const se_LineString = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Position(entry, context);
    });
};
const se_Position = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.serializeFloat)(entry);
    });
};
const se_RoadSnapTracePoint = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Heading: smithy_client_1.serializeFloat,
        Position: (_) => se_Position(_, context),
        Speed: smithy_client_1.serializeFloat,
        Timestamp: [],
    });
};
const se_RoadSnapTracePointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RoadSnapTracePoint(entry, context);
    });
};
const se_RouteAvoidanceArea = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Except: (_) => se_RouteAvoidanceAreaGeometryList(_, context),
        Geometry: (_) => se_RouteAvoidanceAreaGeometry(_, context),
    });
};
const se_RouteAvoidanceAreaGeometry = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        BoundingBox: (_) => se_BoundingBox(_, context),
        Corridor: (_) => se_Corridor(_, context),
        Polygon: (_) => se_LinearRings(_, context),
        PolylineCorridor: smithy_client_1._json,
        PolylinePolygon: smithy_client_1._json,
    });
};
const se_RouteAvoidanceAreaGeometryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteAvoidanceAreaGeometry(entry, context);
    });
};
const se_RouteAvoidanceAreaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteAvoidanceArea(entry, context);
    });
};
const se_RouteAvoidanceOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Areas: (_) => se_RouteAvoidanceAreaList(_, context),
        CarShuttleTrains: [],
        ControlledAccessHighways: [],
        DirtRoads: [],
        Ferries: [],
        SeasonalClosure: [],
        TollRoads: [],
        TollTransponders: [],
        TruckRoadTypes: smithy_client_1._json,
        Tunnels: [],
        UTurns: [],
        ZoneCategories: smithy_client_1._json,
    });
};
const se_RouteCarOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        EngineType: [],
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
    });
};
const se_RouteDestinationOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AvoidActionsForDistance: [],
        AvoidUTurns: [],
        Heading: smithy_client_1.serializeFloat,
        Matching: smithy_client_1._json,
        SideOfStreet: (_) => se_RouteSideOfStreetOptions(_, context),
        StopDuration: [],
    });
};
const se_RouteMatrixAvoidanceArea = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Geometry: (_) => se_RouteMatrixAvoidanceAreaGeometry(_, context),
    });
};
const se_RouteMatrixAvoidanceAreaGeometry = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        BoundingBox: (_) => se_BoundingBox(_, context),
        Polygon: (_) => se_LinearRings(_, context),
        PolylinePolygon: smithy_client_1._json,
    });
};
const se_RouteMatrixAvoidanceAreaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteMatrixAvoidanceArea(entry, context);
    });
};
const se_RouteMatrixAvoidanceOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Areas: (_) => se_RouteMatrixAvoidanceAreaList(_, context),
        CarShuttleTrains: [],
        ControlledAccessHighways: [],
        DirtRoads: [],
        Ferries: [],
        TollRoads: [],
        TollTransponders: [],
        TruckRoadTypes: smithy_client_1._json,
        Tunnels: [],
        UTurns: [],
        ZoneCategories: smithy_client_1._json,
    });
};
const se_RouteMatrixBoundary = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Geometry: (_) => se_RouteMatrixBoundaryGeometry(_, context),
        Unbounded: [],
    });
};
const se_RouteMatrixBoundaryGeometry = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AutoCircle: smithy_client_1._json,
        BoundingBox: (_) => se_BoundingBox(_, context),
        Circle: (_) => se_Circle(_, context),
        Polygon: (_) => se_LinearRings(_, context),
    });
};
const se_RouteMatrixCarOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
    });
};
const se_RouteMatrixDestination = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Options: (_) => se_RouteMatrixDestinationOptions(_, context),
        Position: (_) => se_Position(_, context),
    });
};
const se_RouteMatrixDestinationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteMatrixDestination(entry, context);
    });
};
const se_RouteMatrixDestinationOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AvoidActionsForDistance: [],
        Heading: smithy_client_1.serializeFloat,
        Matching: smithy_client_1._json,
        SideOfStreet: (_) => se_RouteMatrixSideOfStreetOptions(_, context),
    });
};
const se_RouteMatrixOrigin = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Options: (_) => se_RouteMatrixOriginOptions(_, context),
        Position: (_) => se_Position(_, context),
    });
};
const se_RouteMatrixOriginList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteMatrixOrigin(entry, context);
    });
};
const se_RouteMatrixOriginOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AvoidActionsForDistance: [],
        Heading: smithy_client_1.serializeFloat,
        Matching: smithy_client_1._json,
        SideOfStreet: (_) => se_RouteMatrixSideOfStreetOptions(_, context),
    });
};
const se_RouteMatrixScooterOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
    });
};
const se_RouteMatrixSideOfStreetOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Position: (_) => se_Position(_, context),
        UseWith: [],
    });
};
const se_RouteMatrixTravelModeOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Car: (_) => se_RouteMatrixCarOptions(_, context),
        Scooter: (_) => se_RouteMatrixScooterOptions(_, context),
        Truck: (_) => se_RouteMatrixTruckOptions(_, context),
    });
};
const se_RouteMatrixTruckOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AxleCount: [],
        GrossWeight: [],
        HazardousCargos: smithy_client_1._json,
        Height: [],
        KpraLength: [],
        Length: [],
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
        PayloadCapacity: [],
        Trailer: smithy_client_1._json,
        TruckType: [],
        TunnelRestrictionCode: [],
        WeightPerAxle: [],
        WeightPerAxleGroup: smithy_client_1._json,
        Width: [],
    });
};
const se_RouteOriginOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AvoidActionsForDistance: [],
        AvoidUTurns: [],
        Heading: smithy_client_1.serializeFloat,
        Matching: smithy_client_1._json,
        SideOfStreet: (_) => se_RouteSideOfStreetOptions(_, context),
    });
};
const se_RoutePedestrianOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Speed: smithy_client_1.serializeFloat,
    });
};
const se_RouteScooterOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        EngineType: [],
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
    });
};
const se_RouteSideOfStreetOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Position: (_) => se_Position(_, context),
        UseWith: [],
    });
};
const se_RouteTravelModeOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Car: (_) => se_RouteCarOptions(_, context),
        Pedestrian: (_) => se_RoutePedestrianOptions(_, context),
        Scooter: (_) => se_RouteScooterOptions(_, context),
        Truck: (_) => se_RouteTruckOptions(_, context),
    });
};
const se_RouteTruckOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AxleCount: [],
        EngineType: [],
        GrossWeight: [],
        HazardousCargos: smithy_client_1._json,
        Height: [],
        HeightAboveFirstAxle: [],
        KpraLength: [],
        Length: [],
        LicensePlate: smithy_client_1._json,
        MaxSpeed: smithy_client_1.serializeFloat,
        Occupancy: [],
        PayloadCapacity: [],
        TireCount: [],
        Trailer: smithy_client_1._json,
        TruckType: [],
        TunnelRestrictionCode: [],
        WeightPerAxle: [],
        WeightPerAxleGroup: smithy_client_1._json,
        Width: [],
    });
};
const se_RouteWaypoint = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AvoidActionsForDistance: [],
        AvoidUTurns: [],
        Heading: smithy_client_1.serializeFloat,
        Matching: smithy_client_1._json,
        PassThrough: [],
        Position: (_) => se_Position(_, context),
        SideOfStreet: (_) => se_RouteSideOfStreetOptions(_, context),
        StopDuration: [],
    });
};
const se_RouteWaypointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteWaypoint(entry, context);
    });
};
const se_WaypointOptimizationAvoidanceArea = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Geometry: (_) => se_WaypointOptimizationAvoidanceAreaGeometry(_, context),
    });
};
const se_WaypointOptimizationAvoidanceAreaGeometry = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        BoundingBox: (_) => se_BoundingBox(_, context),
    });
};
const se_WaypointOptimizationAvoidanceAreaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_WaypointOptimizationAvoidanceArea(entry, context);
    });
};
const se_WaypointOptimizationAvoidanceOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Areas: (_) => se_WaypointOptimizationAvoidanceAreaList(_, context),
        CarShuttleTrains: [],
        ControlledAccessHighways: [],
        DirtRoads: [],
        Ferries: [],
        TollRoads: [],
        Tunnels: [],
        UTurns: [],
    });
};
const se_WaypointOptimizationDestinationOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AccessHours: smithy_client_1._json,
        AppointmentTime: [],
        Heading: smithy_client_1.serializeFloat,
        Id: [],
        ServiceDuration: [],
        SideOfStreet: (_) => se_WaypointOptimizationSideOfStreetOptions(_, context),
    });
};
const se_WaypointOptimizationPedestrianOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Speed: smithy_client_1.serializeFloat,
    });
};
const se_WaypointOptimizationSideOfStreetOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Position: (_) => se_Position(_, context),
        UseWith: [],
    });
};
const se_WaypointOptimizationTravelModeOptions = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        Pedestrian: (_) => se_WaypointOptimizationPedestrianOptions(_, context),
        Truck: smithy_client_1._json,
    });
};
const se_WaypointOptimizationWaypoint = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        AccessHours: smithy_client_1._json,
        AppointmentTime: [],
        Before: smithy_client_1._json,
        Heading: smithy_client_1.serializeFloat,
        Id: [],
        Position: (_) => se_Position(_, context),
        ServiceDuration: [],
        SideOfStreet: (_) => se_WaypointOptimizationSideOfStreetOptions(_, context),
    });
};
const se_WaypointOptimizationWaypointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_WaypointOptimizationWaypoint(entry, context);
    });
};
const de_BoundingBox = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.limitedParseDouble)(entry);
    });
    return retVal;
};
const de_Circle = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Center: (_) => de_Position(_, context),
        Radius: smithy_client_1.limitedParseDouble,
    });
};
const de_Isoline = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Connections: (_) => de_IsolineConnectionList(_, context),
        DistanceThreshold: smithy_client_1.expectLong,
        Geometries: (_) => de_IsolineShapeGeometryList(_, context),
        TimeThreshold: smithy_client_1.expectLong,
    });
};
const de_IsolineConnection = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        FromPolygonIndex: smithy_client_1.expectInt32,
        Geometry: (_) => de_IsolineConnectionGeometry(_, context),
        ToPolygonIndex: smithy_client_1.expectInt32,
    });
};
const de_IsolineConnectionGeometry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        LineString: (_) => de_LineString(_, context),
        Polyline: smithy_client_1.expectString,
    });
};
const de_IsolineConnectionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IsolineConnection(entry, context);
    });
    return retVal;
};
const de_IsolineList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Isoline(entry, context);
    });
    return retVal;
};
const de_IsolineShapeGeometry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Polygon: (_) => de_LinearRings(_, context),
        PolylinePolygon: smithy_client_1._json,
    });
};
const de_IsolineShapeGeometryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IsolineShapeGeometry(entry, context);
    });
    return retVal;
};
const de_LinearRing = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Position(entry, context);
    });
    return retVal;
};
const de_LinearRings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LinearRing(entry, context);
    });
    return retVal;
};
const de_LineString = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Position(entry, context);
    });
    return retVal;
};
const de_Position = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.limitedParseDouble)(entry);
    });
    return retVal;
};
const de_Position23 = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.limitedParseDouble)(entry);
    });
    return retVal;
};
const de_RoadSnapSnappedGeometry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        LineString: (_) => de_LineString(_, context),
        Polyline: smithy_client_1.expectString,
    });
};
const de_RoadSnapSnappedTracePoint = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Confidence: smithy_client_1.limitedParseDouble,
        OriginalPosition: (_) => de_Position(_, context),
        SnappedPosition: (_) => de_Position(_, context),
    });
};
const de_RoadSnapSnappedTracePointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoadSnapSnappedTracePoint(entry, context);
    });
    return retVal;
};
const de_Route = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Legs: (_) => de_RouteLegList(_, context),
        MajorRoadLabels: smithy_client_1._json,
        Summary: (_) => de_RouteSummary(_, context),
    });
};
const de_RouteContinueHighwayStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteEnterHighwayStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteExitStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        RelativeExit: smithy_client_1.expectInt32,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteFerryArrival = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Place: (_) => de_RouteFerryPlace(_, context),
        Time: smithy_client_1.expectString,
    });
};
const de_RouteFerryDeparture = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Place: (_) => de_RouteFerryPlace(_, context),
        Time: smithy_client_1.expectString,
    });
};
const de_RouteFerryLegDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AfterTravelSteps: smithy_client_1._json,
        Arrival: (_) => de_RouteFerryArrival(_, context),
        BeforeTravelSteps: smithy_client_1._json,
        Departure: (_) => de_RouteFerryDeparture(_, context),
        Notices: smithy_client_1._json,
        PassThroughWaypoints: (_) => de_RoutePassThroughWaypointList(_, context),
        RouteName: smithy_client_1.expectString,
        Spans: smithy_client_1._json,
        Summary: smithy_client_1._json,
        TravelSteps: smithy_client_1._json,
    });
};
const de_RouteFerryPlace = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Name: smithy_client_1.expectString,
        OriginalPosition: (_) => de_Position23(_, context),
        Position: (_) => de_Position23(_, context),
        WaypointIndex: smithy_client_1.expectInt32,
    });
};
const de_RouteKeepStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteLeg = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        FerryLegDetails: (_) => de_RouteFerryLegDetails(_, context),
        Geometry: (_) => de_RouteLegGeometry(_, context),
        Language: smithy_client_1.expectString,
        PedestrianLegDetails: (_) => de_RoutePedestrianLegDetails(_, context),
        TravelMode: smithy_client_1.expectString,
        Type: smithy_client_1.expectString,
        VehicleLegDetails: (_) => de_RouteVehicleLegDetails(_, context),
    });
};
const de_RouteLegGeometry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        LineString: (_) => de_LineString(_, context),
        Polyline: smithy_client_1.expectString,
    });
};
const de_RouteLegList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteLeg(entry, context);
    });
    return retVal;
};
const de_RouteList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Route(entry, context);
    });
    return retVal;
};
const de_RouteMatrixBoundary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Geometry: (_) => de_RouteMatrixBoundaryGeometry(_, context),
        Unbounded: smithy_client_1.expectBoolean,
    });
};
const de_RouteMatrixBoundaryGeometry = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        AutoCircle: smithy_client_1._json,
        BoundingBox: (_) => de_BoundingBox(_, context),
        Circle: (_) => de_Circle(_, context),
        Polygon: (_) => de_LinearRings(_, context),
    });
};
const de_RoutePassThroughPlace = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        OriginalPosition: (_) => de_Position23(_, context),
        Position: (_) => de_Position23(_, context),
        WaypointIndex: smithy_client_1.expectInt32,
    });
};
const de_RoutePassThroughWaypoint = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        GeometryOffset: smithy_client_1.expectInt32,
        Place: (_) => de_RoutePassThroughPlace(_, context),
    });
};
const de_RoutePassThroughWaypointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoutePassThroughWaypoint(entry, context);
    });
    return retVal;
};
const de_RoutePedestrianArrival = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Place: (_) => de_RoutePedestrianPlace(_, context),
        Time: smithy_client_1.expectString,
    });
};
const de_RoutePedestrianDeparture = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Place: (_) => de_RoutePedestrianPlace(_, context),
        Time: smithy_client_1.expectString,
    });
};
const de_RoutePedestrianLegDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Arrival: (_) => de_RoutePedestrianArrival(_, context),
        Departure: (_) => de_RoutePedestrianDeparture(_, context),
        Notices: smithy_client_1._json,
        PassThroughWaypoints: (_) => de_RoutePassThroughWaypointList(_, context),
        Spans: (_) => de_RoutePedestrianSpanList(_, context),
        Summary: smithy_client_1._json,
        TravelSteps: (_) => de_RoutePedestrianTravelStepList(_, context),
    });
};
const de_RoutePedestrianPlace = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Name: smithy_client_1.expectString,
        OriginalPosition: (_) => de_Position23(_, context),
        Position: (_) => de_Position23(_, context),
        SideOfStreet: smithy_client_1.expectString,
        WaypointIndex: smithy_client_1.expectInt32,
    });
};
const de_RoutePedestrianSpan = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BestCaseDuration: smithy_client_1.expectLong,
        Country: smithy_client_1.expectString,
        Distance: smithy_client_1.expectLong,
        Duration: smithy_client_1.expectLong,
        DynamicSpeed: (_) => de_RouteSpanDynamicSpeedDetails(_, context),
        FunctionalClassification: smithy_client_1.expectInt32,
        GeometryOffset: smithy_client_1.expectInt32,
        Incidents: smithy_client_1._json,
        Names: smithy_client_1._json,
        PedestrianAccess: smithy_client_1._json,
        Region: smithy_client_1.expectString,
        RoadAttributes: smithy_client_1._json,
        RouteNumbers: smithy_client_1._json,
        SpeedLimit: (_) => de_RouteSpanSpeedLimitDetails(_, context),
        TypicalDuration: smithy_client_1.expectLong,
    });
};
const de_RoutePedestrianSpanList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoutePedestrianSpan(entry, context);
    });
    return retVal;
};
const de_RoutePedestrianTravelStep = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ContinueStepDetails: smithy_client_1._json,
        CurrentRoad: smithy_client_1._json,
        Distance: smithy_client_1.expectLong,
        Duration: smithy_client_1.expectLong,
        ExitNumber: smithy_client_1._json,
        GeometryOffset: smithy_client_1.expectInt32,
        Instruction: smithy_client_1.expectString,
        KeepStepDetails: (_) => de_RouteKeepStepDetails(_, context),
        NextRoad: smithy_client_1._json,
        RoundaboutEnterStepDetails: (_) => de_RouteRoundaboutEnterStepDetails(_, context),
        RoundaboutExitStepDetails: (_) => de_RouteRoundaboutExitStepDetails(_, context),
        RoundaboutPassStepDetails: (_) => de_RouteRoundaboutPassStepDetails(_, context),
        Signpost: smithy_client_1._json,
        TurnStepDetails: (_) => de_RouteTurnStepDetails(_, context),
        Type: smithy_client_1.expectString,
    });
};
const de_RoutePedestrianTravelStepList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoutePedestrianTravelStep(entry, context);
    });
    return retVal;
};
const de_RouteRampStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteRoundaboutEnterStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteRoundaboutExitStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        RelativeExit: smithy_client_1.expectInt32,
        RoundaboutAngle: smithy_client_1.limitedParseDouble,
        SteeringDirection: smithy_client_1.expectString,
    });
};
const de_RouteRoundaboutPassStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteSpanDynamicSpeedDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BestCaseSpeed: smithy_client_1.limitedParseDouble,
        TurnDuration: smithy_client_1.expectLong,
        TypicalSpeed: smithy_client_1.limitedParseDouble,
    });
};
const de_RouteSpanSpeedLimitDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        MaxSpeed: smithy_client_1.limitedParseDouble,
        Unlimited: smithy_client_1.expectBoolean,
    });
};
const de_RouteSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Distance: smithy_client_1.expectLong,
        Duration: smithy_client_1.expectLong,
        Tolls: (_) => de_RouteTollSummary(_, context),
    });
};
const de_RouteToll = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Country: smithy_client_1.expectString,
        PaymentSites: (_) => de_RouteTollPaymentSiteList(_, context),
        Rates: (_) => de_RouteTollRateList(_, context),
        Systems: smithy_client_1._json,
    });
};
const de_RouteTollList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteToll(entry, context);
    });
    return retVal;
};
const de_RouteTollPaymentSite = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Name: smithy_client_1.expectString,
        Position: (_) => de_Position23(_, context),
    });
};
const de_RouteTollPaymentSiteList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteTollPaymentSite(entry, context);
    });
    return retVal;
};
const de_RouteTollPrice = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Currency: smithy_client_1.expectString,
        Estimate: smithy_client_1.expectBoolean,
        PerDuration: smithy_client_1.expectLong,
        Range: smithy_client_1.expectBoolean,
        RangeValue: (_) => de_RouteTollPriceValueRange(_, context),
        Value: smithy_client_1.limitedParseDouble,
    });
};
const de_RouteTollPriceSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Currency: smithy_client_1.expectString,
        Estimate: smithy_client_1.expectBoolean,
        Range: smithy_client_1.expectBoolean,
        RangeValue: (_) => de_RouteTollPriceValueRange(_, context),
        Value: smithy_client_1.limitedParseDouble,
    });
};
const de_RouteTollPriceValueRange = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Max: smithy_client_1.limitedParseDouble,
        Min: smithy_client_1.limitedParseDouble,
    });
};
const de_RouteTollRate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ApplicableTimes: smithy_client_1.expectString,
        ConvertedPrice: (_) => de_RouteTollPrice(_, context),
        Id: smithy_client_1.expectString,
        LocalPrice: (_) => de_RouteTollPrice(_, context),
        Name: smithy_client_1.expectString,
        Pass: smithy_client_1._json,
        PaymentMethods: smithy_client_1._json,
        Transponders: smithy_client_1._json,
    });
};
const de_RouteTollRateList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteTollRate(entry, context);
    });
    return retVal;
};
const de_RouteTollSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Total: (_) => de_RouteTollPriceSummary(_, context),
    });
};
const de_RouteTurnStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteUTurnStepDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Intersection: smithy_client_1._json,
        SteeringDirection: smithy_client_1.expectString,
        TurnAngle: smithy_client_1.limitedParseDouble,
        TurnIntensity: smithy_client_1.expectString,
    });
};
const de_RouteVehicleArrival = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Place: (_) => de_RouteVehiclePlace(_, context),
        Time: smithy_client_1.expectString,
    });
};
const de_RouteVehicleDeparture = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Place: (_) => de_RouteVehiclePlace(_, context),
        Time: smithy_client_1.expectString,
    });
};
const de_RouteVehicleLegDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Arrival: (_) => de_RouteVehicleArrival(_, context),
        Departure: (_) => de_RouteVehicleDeparture(_, context),
        Incidents: smithy_client_1._json,
        Notices: smithy_client_1._json,
        PassThroughWaypoints: (_) => de_RoutePassThroughWaypointList(_, context),
        Spans: (_) => de_RouteVehicleSpanList(_, context),
        Summary: smithy_client_1._json,
        TollSystems: smithy_client_1._json,
        Tolls: (_) => de_RouteTollList(_, context),
        TravelSteps: (_) => de_RouteVehicleTravelStepList(_, context),
        TruckRoadTypes: smithy_client_1._json,
        Zones: smithy_client_1._json,
    });
};
const de_RouteVehiclePlace = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Name: smithy_client_1.expectString,
        OriginalPosition: (_) => de_Position23(_, context),
        Position: (_) => de_Position23(_, context),
        SideOfStreet: smithy_client_1.expectString,
        WaypointIndex: smithy_client_1.expectInt32,
    });
};
const de_RouteVehicleSpan = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        BestCaseDuration: smithy_client_1.expectLong,
        CarAccess: smithy_client_1._json,
        Country: smithy_client_1.expectString,
        Distance: smithy_client_1.expectLong,
        Duration: smithy_client_1.expectLong,
        DynamicSpeed: (_) => de_RouteSpanDynamicSpeedDetails(_, context),
        FunctionalClassification: smithy_client_1.expectInt32,
        Gate: smithy_client_1.expectString,
        GeometryOffset: smithy_client_1.expectInt32,
        Incidents: smithy_client_1._json,
        Names: smithy_client_1._json,
        Notices: smithy_client_1._json,
        RailwayCrossing: smithy_client_1.expectString,
        Region: smithy_client_1.expectString,
        RoadAttributes: smithy_client_1._json,
        RouteNumbers: smithy_client_1._json,
        ScooterAccess: smithy_client_1._json,
        SpeedLimit: (_) => de_RouteSpanSpeedLimitDetails(_, context),
        TollSystems: smithy_client_1._json,
        TruckAccess: smithy_client_1._json,
        TruckRoadTypes: smithy_client_1._json,
        TypicalDuration: smithy_client_1.expectLong,
        Zones: smithy_client_1._json,
    });
};
const de_RouteVehicleSpanList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteVehicleSpan(entry, context);
    });
    return retVal;
};
const de_RouteVehicleTravelStep = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ContinueHighwayStepDetails: (_) => de_RouteContinueHighwayStepDetails(_, context),
        ContinueStepDetails: smithy_client_1._json,
        CurrentRoad: smithy_client_1._json,
        Distance: smithy_client_1.expectLong,
        Duration: smithy_client_1.expectLong,
        EnterHighwayStepDetails: (_) => de_RouteEnterHighwayStepDetails(_, context),
        ExitNumber: smithy_client_1._json,
        ExitStepDetails: (_) => de_RouteExitStepDetails(_, context),
        GeometryOffset: smithy_client_1.expectInt32,
        Instruction: smithy_client_1.expectString,
        KeepStepDetails: (_) => de_RouteKeepStepDetails(_, context),
        NextRoad: smithy_client_1._json,
        RampStepDetails: (_) => de_RouteRampStepDetails(_, context),
        RoundaboutEnterStepDetails: (_) => de_RouteRoundaboutEnterStepDetails(_, context),
        RoundaboutExitStepDetails: (_) => de_RouteRoundaboutExitStepDetails(_, context),
        RoundaboutPassStepDetails: (_) => de_RouteRoundaboutPassStepDetails(_, context),
        Signpost: smithy_client_1._json,
        TurnStepDetails: (_) => de_RouteTurnStepDetails(_, context),
        Type: smithy_client_1.expectString,
        UTurnStepDetails: (_) => de_RouteUTurnStepDetails(_, context),
    });
};
const de_RouteVehicleTravelStepList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteVehicleTravelStep(entry, context);
    });
    return retVal;
};
const de_ValidationExceptionField = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Message: [, smithy_client_1.expectString, `message`],
        Name: [, smithy_client_1.expectString, `name`],
    });
};
const de_ValidationExceptionFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ValidationExceptionField(entry, context);
    });
    return retVal;
};
const de_WaypointOptimizationImpedingWaypoint = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        FailedConstraints: smithy_client_1._json,
        Id: smithy_client_1.expectString,
        Position: (_) => de_Position(_, context),
    });
};
const de_WaypointOptimizationImpedingWaypointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_WaypointOptimizationImpedingWaypoint(entry, context);
    });
    return retVal;
};
const de_WaypointOptimizationOptimizedWaypoint = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        ArrivalTime: smithy_client_1.expectString,
        ClusterIndex: smithy_client_1.expectInt32,
        DepartureTime: smithy_client_1.expectString,
        Id: smithy_client_1.expectString,
        Position: (_) => de_Position(_, context),
    });
};
const de_WaypointOptimizationOptimizedWaypointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_WaypointOptimizationOptimizedWaypoint(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const _K = "Key";
const _PB = "PricingBucket";
const _k = "key";
const _xagpb = "x-amz-geo-pricing-bucket";
