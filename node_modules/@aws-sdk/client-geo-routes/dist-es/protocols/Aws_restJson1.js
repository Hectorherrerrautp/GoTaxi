import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { GeoRoutesServiceException as __BaseException } from "../models/GeoRoutesServiceException";
import { AccessDeniedException, InternalServerException, ThrottlingException, ValidationException, } from "../models/models_0";
export const se_CalculateIsolinesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/isolines");
    const query = map({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify(take(input, {
        Allow: (_) => _json(_),
        ArrivalTime: [],
        Avoid: (_) => se_IsolineAvoidanceOptions(_, context),
        DepartNow: [],
        DepartureTime: [],
        Destination: (_) => se_Position(_, context),
        DestinationOptions: (_) => se_IsolineDestinationOptions(_, context),
        IsolineGeometryFormat: [],
        IsolineGranularity: (_) => _json(_),
        OptimizeIsolineFor: [],
        OptimizeRoutingFor: [],
        Origin: (_) => se_Position(_, context),
        OriginOptions: (_) => se_IsolineOriginOptions(_, context),
        Thresholds: (_) => _json(_),
        Traffic: (_) => _json(_),
        TravelMode: [],
        TravelModeOptions: (_) => se_IsolineTravelModeOptions(_, context),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CalculateRouteMatrixCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/route-matrix");
    const query = map({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify(take(input, {
        Allow: (_) => _json(_),
        Avoid: (_) => se_RouteMatrixAvoidanceOptions(_, context),
        DepartNow: [],
        DepartureTime: [],
        Destinations: (_) => se_RouteMatrixDestinationList(_, context),
        Exclude: (_) => _json(_),
        OptimizeRoutingFor: [],
        Origins: (_) => se_RouteMatrixOriginList(_, context),
        RoutingBoundary: (_) => se_RouteMatrixBoundary(_, context),
        Traffic: (_) => _json(_),
        TravelMode: [],
        TravelModeOptions: (_) => se_RouteMatrixTravelModeOptions(_, context),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CalculateRoutesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/routes");
    const query = map({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify(take(input, {
        Allow: (_) => _json(_),
        ArrivalTime: [],
        Avoid: (_) => se_RouteAvoidanceOptions(_, context),
        DepartNow: [],
        DepartureTime: [],
        Destination: (_) => se_Position(_, context),
        DestinationOptions: (_) => se_RouteDestinationOptions(_, context),
        Driver: (_) => _json(_),
        Exclude: (_) => _json(_),
        InstructionsMeasurementSystem: [],
        Languages: (_) => _json(_),
        LegAdditionalFeatures: (_) => _json(_),
        LegGeometryFormat: [],
        MaxAlternatives: [],
        OptimizeRoutingFor: [],
        Origin: (_) => se_Position(_, context),
        OriginOptions: (_) => se_RouteOriginOptions(_, context),
        SpanAdditionalFeatures: (_) => _json(_),
        Tolls: (_) => _json(_),
        Traffic: (_) => _json(_),
        TravelMode: [],
        TravelModeOptions: (_) => se_RouteTravelModeOptions(_, context),
        TravelStepType: [],
        Waypoints: (_) => se_RouteWaypointList(_, context),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_OptimizeWaypointsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/optimize-waypoints");
    const query = map({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify(take(input, {
        Avoid: (_) => se_WaypointOptimizationAvoidanceOptions(_, context),
        Clustering: (_) => _json(_),
        DepartureTime: [],
        Destination: (_) => se_Position(_, context),
        DestinationOptions: (_) => se_WaypointOptimizationDestinationOptions(_, context),
        Driver: (_) => _json(_),
        Exclude: (_) => _json(_),
        OptimizeSequencingFor: [],
        Origin: (_) => se_Position(_, context),
        OriginOptions: (_) => _json(_),
        Traffic: (_) => _json(_),
        TravelMode: [],
        TravelModeOptions: (_) => se_WaypointOptimizationTravelModeOptions(_, context),
        Waypoints: (_) => se_WaypointOptimizationWaypointList(_, context),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_SnapToRoadsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/snap-to-roads");
    const query = map({
        [_k]: [, input[_K]],
    });
    let body;
    body = JSON.stringify(take(input, {
        SnapRadius: [],
        SnappedGeometryFormat: [],
        TracePoints: (_) => se_RoadSnapTracePointList(_, context),
        TravelMode: [],
        TravelModeOptions: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const de_CalculateIsolinesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ArrivalTime: __expectString,
        DepartureTime: __expectString,
        IsolineGeometryFormat: __expectString,
        Isolines: (_) => de_IsolineList(_, context),
        SnappedDestination: (_) => de_Position(_, context),
        SnappedOrigin: (_) => de_Position(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CalculateRouteMatrixCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ErrorCount: __expectInt32,
        RouteMatrix: _json,
        RoutingBoundary: (_) => de_RouteMatrixBoundary(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CalculateRoutesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        LegGeometryFormat: __expectString,
        Notices: _json,
        Routes: (_) => de_RouteList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_OptimizeWaypointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Connections: _json,
        Distance: __expectLong,
        Duration: __expectLong,
        ImpedingWaypoints: (_) => de_WaypointOptimizationImpedingWaypointList(_, context),
        OptimizedWaypoints: (_) => de_WaypointOptimizationOptimizedWaypointList(_, context),
        TimeBreakdown: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_SnapToRoadsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_PB]: [, output.headers[_xagpb]],
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Notices: _json,
        SnappedGeometry: (_) => de_RoadSnapSnappedGeometry(_, context),
        SnappedGeometryFormat: __expectString,
        SnappedTracePoints: (_) => de_RoadSnapSnappedTracePointList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.georoutes#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.georoutes#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.georoutes#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.georoutes#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        FieldList: [, (_) => de_ValidationExceptionFieldList(_, context), `fieldList`],
        Message: [, __expectString, `message`],
        Reason: [, __expectString, `reason`],
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_BoundingBox = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return __serializeFloat(entry);
    });
};
const se_Circle = (input, context) => {
    return take(input, {
        Center: (_) => se_Position(_, context),
        Radius: __serializeFloat,
    });
};
const se_Corridor = (input, context) => {
    return take(input, {
        LineString: (_) => se_LineString(_, context),
        Radius: [],
    });
};
const se_IsolineAvoidanceArea = (input, context) => {
    return take(input, {
        Except: (_) => se_IsolineAvoidanceAreaGeometryList(_, context),
        Geometry: (_) => se_IsolineAvoidanceAreaGeometry(_, context),
    });
};
const se_IsolineAvoidanceAreaGeometry = (input, context) => {
    return take(input, {
        BoundingBox: (_) => se_BoundingBox(_, context),
        Corridor: (_) => se_Corridor(_, context),
        Polygon: (_) => se_LinearRings(_, context),
        PolylineCorridor: _json,
        PolylinePolygon: _json,
    });
};
const se_IsolineAvoidanceAreaGeometryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_IsolineAvoidanceAreaGeometry(entry, context);
    });
};
const se_IsolineAvoidanceAreaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_IsolineAvoidanceArea(entry, context);
    });
};
const se_IsolineAvoidanceOptions = (input, context) => {
    return take(input, {
        Areas: (_) => se_IsolineAvoidanceAreaList(_, context),
        CarShuttleTrains: [],
        ControlledAccessHighways: [],
        DirtRoads: [],
        Ferries: [],
        SeasonalClosure: [],
        TollRoads: [],
        TollTransponders: [],
        TruckRoadTypes: _json,
        Tunnels: [],
        UTurns: [],
        ZoneCategories: _json,
    });
};
const se_IsolineCarOptions = (input, context) => {
    return take(input, {
        EngineType: [],
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
    });
};
const se_IsolineDestinationOptions = (input, context) => {
    return take(input, {
        AvoidActionsForDistance: [],
        Heading: __serializeFloat,
        Matching: _json,
        SideOfStreet: (_) => se_IsolineSideOfStreetOptions(_, context),
    });
};
const se_IsolineOriginOptions = (input, context) => {
    return take(input, {
        AvoidActionsForDistance: [],
        Heading: __serializeFloat,
        Matching: _json,
        SideOfStreet: (_) => se_IsolineSideOfStreetOptions(_, context),
    });
};
const se_IsolineScooterOptions = (input, context) => {
    return take(input, {
        EngineType: [],
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
    });
};
const se_IsolineSideOfStreetOptions = (input, context) => {
    return take(input, {
        Position: (_) => se_Position(_, context),
        UseWith: [],
    });
};
const se_IsolineTravelModeOptions = (input, context) => {
    return take(input, {
        Car: (_) => se_IsolineCarOptions(_, context),
        Scooter: (_) => se_IsolineScooterOptions(_, context),
        Truck: (_) => se_IsolineTruckOptions(_, context),
    });
};
const se_IsolineTruckOptions = (input, context) => {
    return take(input, {
        AxleCount: [],
        EngineType: [],
        GrossWeight: [],
        HazardousCargos: _json,
        Height: [],
        HeightAboveFirstAxle: [],
        KpraLength: [],
        Length: [],
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
        PayloadCapacity: [],
        TireCount: [],
        Trailer: _json,
        TruckType: [],
        TunnelRestrictionCode: [],
        WeightPerAxle: [],
        WeightPerAxleGroup: _json,
        Width: [],
    });
};
const se_LinearRing = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Position(entry, context);
    });
};
const se_LinearRings = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_LinearRing(entry, context);
    });
};
const se_LineString = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Position(entry, context);
    });
};
const se_Position = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return __serializeFloat(entry);
    });
};
const se_RoadSnapTracePoint = (input, context) => {
    return take(input, {
        Heading: __serializeFloat,
        Position: (_) => se_Position(_, context),
        Speed: __serializeFloat,
        Timestamp: [],
    });
};
const se_RoadSnapTracePointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RoadSnapTracePoint(entry, context);
    });
};
const se_RouteAvoidanceArea = (input, context) => {
    return take(input, {
        Except: (_) => se_RouteAvoidanceAreaGeometryList(_, context),
        Geometry: (_) => se_RouteAvoidanceAreaGeometry(_, context),
    });
};
const se_RouteAvoidanceAreaGeometry = (input, context) => {
    return take(input, {
        BoundingBox: (_) => se_BoundingBox(_, context),
        Corridor: (_) => se_Corridor(_, context),
        Polygon: (_) => se_LinearRings(_, context),
        PolylineCorridor: _json,
        PolylinePolygon: _json,
    });
};
const se_RouteAvoidanceAreaGeometryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteAvoidanceAreaGeometry(entry, context);
    });
};
const se_RouteAvoidanceAreaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteAvoidanceArea(entry, context);
    });
};
const se_RouteAvoidanceOptions = (input, context) => {
    return take(input, {
        Areas: (_) => se_RouteAvoidanceAreaList(_, context),
        CarShuttleTrains: [],
        ControlledAccessHighways: [],
        DirtRoads: [],
        Ferries: [],
        SeasonalClosure: [],
        TollRoads: [],
        TollTransponders: [],
        TruckRoadTypes: _json,
        Tunnels: [],
        UTurns: [],
        ZoneCategories: _json,
    });
};
const se_RouteCarOptions = (input, context) => {
    return take(input, {
        EngineType: [],
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
    });
};
const se_RouteDestinationOptions = (input, context) => {
    return take(input, {
        AvoidActionsForDistance: [],
        AvoidUTurns: [],
        Heading: __serializeFloat,
        Matching: _json,
        SideOfStreet: (_) => se_RouteSideOfStreetOptions(_, context),
        StopDuration: [],
    });
};
const se_RouteMatrixAvoidanceArea = (input, context) => {
    return take(input, {
        Geometry: (_) => se_RouteMatrixAvoidanceAreaGeometry(_, context),
    });
};
const se_RouteMatrixAvoidanceAreaGeometry = (input, context) => {
    return take(input, {
        BoundingBox: (_) => se_BoundingBox(_, context),
        Polygon: (_) => se_LinearRings(_, context),
        PolylinePolygon: _json,
    });
};
const se_RouteMatrixAvoidanceAreaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteMatrixAvoidanceArea(entry, context);
    });
};
const se_RouteMatrixAvoidanceOptions = (input, context) => {
    return take(input, {
        Areas: (_) => se_RouteMatrixAvoidanceAreaList(_, context),
        CarShuttleTrains: [],
        ControlledAccessHighways: [],
        DirtRoads: [],
        Ferries: [],
        TollRoads: [],
        TollTransponders: [],
        TruckRoadTypes: _json,
        Tunnels: [],
        UTurns: [],
        ZoneCategories: _json,
    });
};
const se_RouteMatrixBoundary = (input, context) => {
    return take(input, {
        Geometry: (_) => se_RouteMatrixBoundaryGeometry(_, context),
        Unbounded: [],
    });
};
const se_RouteMatrixBoundaryGeometry = (input, context) => {
    return take(input, {
        AutoCircle: _json,
        BoundingBox: (_) => se_BoundingBox(_, context),
        Circle: (_) => se_Circle(_, context),
        Polygon: (_) => se_LinearRings(_, context),
    });
};
const se_RouteMatrixCarOptions = (input, context) => {
    return take(input, {
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
    });
};
const se_RouteMatrixDestination = (input, context) => {
    return take(input, {
        Options: (_) => se_RouteMatrixDestinationOptions(_, context),
        Position: (_) => se_Position(_, context),
    });
};
const se_RouteMatrixDestinationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteMatrixDestination(entry, context);
    });
};
const se_RouteMatrixDestinationOptions = (input, context) => {
    return take(input, {
        AvoidActionsForDistance: [],
        Heading: __serializeFloat,
        Matching: _json,
        SideOfStreet: (_) => se_RouteMatrixSideOfStreetOptions(_, context),
    });
};
const se_RouteMatrixOrigin = (input, context) => {
    return take(input, {
        Options: (_) => se_RouteMatrixOriginOptions(_, context),
        Position: (_) => se_Position(_, context),
    });
};
const se_RouteMatrixOriginList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteMatrixOrigin(entry, context);
    });
};
const se_RouteMatrixOriginOptions = (input, context) => {
    return take(input, {
        AvoidActionsForDistance: [],
        Heading: __serializeFloat,
        Matching: _json,
        SideOfStreet: (_) => se_RouteMatrixSideOfStreetOptions(_, context),
    });
};
const se_RouteMatrixScooterOptions = (input, context) => {
    return take(input, {
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
    });
};
const se_RouteMatrixSideOfStreetOptions = (input, context) => {
    return take(input, {
        Position: (_) => se_Position(_, context),
        UseWith: [],
    });
};
const se_RouteMatrixTravelModeOptions = (input, context) => {
    return take(input, {
        Car: (_) => se_RouteMatrixCarOptions(_, context),
        Scooter: (_) => se_RouteMatrixScooterOptions(_, context),
        Truck: (_) => se_RouteMatrixTruckOptions(_, context),
    });
};
const se_RouteMatrixTruckOptions = (input, context) => {
    return take(input, {
        AxleCount: [],
        GrossWeight: [],
        HazardousCargos: _json,
        Height: [],
        KpraLength: [],
        Length: [],
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
        PayloadCapacity: [],
        Trailer: _json,
        TruckType: [],
        TunnelRestrictionCode: [],
        WeightPerAxle: [],
        WeightPerAxleGroup: _json,
        Width: [],
    });
};
const se_RouteOriginOptions = (input, context) => {
    return take(input, {
        AvoidActionsForDistance: [],
        AvoidUTurns: [],
        Heading: __serializeFloat,
        Matching: _json,
        SideOfStreet: (_) => se_RouteSideOfStreetOptions(_, context),
    });
};
const se_RoutePedestrianOptions = (input, context) => {
    return take(input, {
        Speed: __serializeFloat,
    });
};
const se_RouteScooterOptions = (input, context) => {
    return take(input, {
        EngineType: [],
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
    });
};
const se_RouteSideOfStreetOptions = (input, context) => {
    return take(input, {
        Position: (_) => se_Position(_, context),
        UseWith: [],
    });
};
const se_RouteTravelModeOptions = (input, context) => {
    return take(input, {
        Car: (_) => se_RouteCarOptions(_, context),
        Pedestrian: (_) => se_RoutePedestrianOptions(_, context),
        Scooter: (_) => se_RouteScooterOptions(_, context),
        Truck: (_) => se_RouteTruckOptions(_, context),
    });
};
const se_RouteTruckOptions = (input, context) => {
    return take(input, {
        AxleCount: [],
        EngineType: [],
        GrossWeight: [],
        HazardousCargos: _json,
        Height: [],
        HeightAboveFirstAxle: [],
        KpraLength: [],
        Length: [],
        LicensePlate: _json,
        MaxSpeed: __serializeFloat,
        Occupancy: [],
        PayloadCapacity: [],
        TireCount: [],
        Trailer: _json,
        TruckType: [],
        TunnelRestrictionCode: [],
        WeightPerAxle: [],
        WeightPerAxleGroup: _json,
        Width: [],
    });
};
const se_RouteWaypoint = (input, context) => {
    return take(input, {
        AvoidActionsForDistance: [],
        AvoidUTurns: [],
        Heading: __serializeFloat,
        Matching: _json,
        PassThrough: [],
        Position: (_) => se_Position(_, context),
        SideOfStreet: (_) => se_RouteSideOfStreetOptions(_, context),
        StopDuration: [],
    });
};
const se_RouteWaypointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RouteWaypoint(entry, context);
    });
};
const se_WaypointOptimizationAvoidanceArea = (input, context) => {
    return take(input, {
        Geometry: (_) => se_WaypointOptimizationAvoidanceAreaGeometry(_, context),
    });
};
const se_WaypointOptimizationAvoidanceAreaGeometry = (input, context) => {
    return take(input, {
        BoundingBox: (_) => se_BoundingBox(_, context),
    });
};
const se_WaypointOptimizationAvoidanceAreaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_WaypointOptimizationAvoidanceArea(entry, context);
    });
};
const se_WaypointOptimizationAvoidanceOptions = (input, context) => {
    return take(input, {
        Areas: (_) => se_WaypointOptimizationAvoidanceAreaList(_, context),
        CarShuttleTrains: [],
        ControlledAccessHighways: [],
        DirtRoads: [],
        Ferries: [],
        TollRoads: [],
        Tunnels: [],
        UTurns: [],
    });
};
const se_WaypointOptimizationDestinationOptions = (input, context) => {
    return take(input, {
        AccessHours: _json,
        AppointmentTime: [],
        Heading: __serializeFloat,
        Id: [],
        ServiceDuration: [],
        SideOfStreet: (_) => se_WaypointOptimizationSideOfStreetOptions(_, context),
    });
};
const se_WaypointOptimizationPedestrianOptions = (input, context) => {
    return take(input, {
        Speed: __serializeFloat,
    });
};
const se_WaypointOptimizationSideOfStreetOptions = (input, context) => {
    return take(input, {
        Position: (_) => se_Position(_, context),
        UseWith: [],
    });
};
const se_WaypointOptimizationTravelModeOptions = (input, context) => {
    return take(input, {
        Pedestrian: (_) => se_WaypointOptimizationPedestrianOptions(_, context),
        Truck: _json,
    });
};
const se_WaypointOptimizationWaypoint = (input, context) => {
    return take(input, {
        AccessHours: _json,
        AppointmentTime: [],
        Before: _json,
        Heading: __serializeFloat,
        Id: [],
        Position: (_) => se_Position(_, context),
        ServiceDuration: [],
        SideOfStreet: (_) => se_WaypointOptimizationSideOfStreetOptions(_, context),
    });
};
const se_WaypointOptimizationWaypointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_WaypointOptimizationWaypoint(entry, context);
    });
};
const de_BoundingBox = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __limitedParseDouble(entry);
    });
    return retVal;
};
const de_Circle = (output, context) => {
    return take(output, {
        Center: (_) => de_Position(_, context),
        Radius: __limitedParseDouble,
    });
};
const de_Isoline = (output, context) => {
    return take(output, {
        Connections: (_) => de_IsolineConnectionList(_, context),
        DistanceThreshold: __expectLong,
        Geometries: (_) => de_IsolineShapeGeometryList(_, context),
        TimeThreshold: __expectLong,
    });
};
const de_IsolineConnection = (output, context) => {
    return take(output, {
        FromPolygonIndex: __expectInt32,
        Geometry: (_) => de_IsolineConnectionGeometry(_, context),
        ToPolygonIndex: __expectInt32,
    });
};
const de_IsolineConnectionGeometry = (output, context) => {
    return take(output, {
        LineString: (_) => de_LineString(_, context),
        Polyline: __expectString,
    });
};
const de_IsolineConnectionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IsolineConnection(entry, context);
    });
    return retVal;
};
const de_IsolineList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Isoline(entry, context);
    });
    return retVal;
};
const de_IsolineShapeGeometry = (output, context) => {
    return take(output, {
        Polygon: (_) => de_LinearRings(_, context),
        PolylinePolygon: _json,
    });
};
const de_IsolineShapeGeometryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IsolineShapeGeometry(entry, context);
    });
    return retVal;
};
const de_LinearRing = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Position(entry, context);
    });
    return retVal;
};
const de_LinearRings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LinearRing(entry, context);
    });
    return retVal;
};
const de_LineString = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Position(entry, context);
    });
    return retVal;
};
const de_Position = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __limitedParseDouble(entry);
    });
    return retVal;
};
const de_Position23 = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __limitedParseDouble(entry);
    });
    return retVal;
};
const de_RoadSnapSnappedGeometry = (output, context) => {
    return take(output, {
        LineString: (_) => de_LineString(_, context),
        Polyline: __expectString,
    });
};
const de_RoadSnapSnappedTracePoint = (output, context) => {
    return take(output, {
        Confidence: __limitedParseDouble,
        OriginalPosition: (_) => de_Position(_, context),
        SnappedPosition: (_) => de_Position(_, context),
    });
};
const de_RoadSnapSnappedTracePointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoadSnapSnappedTracePoint(entry, context);
    });
    return retVal;
};
const de_Route = (output, context) => {
    return take(output, {
        Legs: (_) => de_RouteLegList(_, context),
        MajorRoadLabels: _json,
        Summary: (_) => de_RouteSummary(_, context),
    });
};
const de_RouteContinueHighwayStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteEnterHighwayStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteExitStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        RelativeExit: __expectInt32,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteFerryArrival = (output, context) => {
    return take(output, {
        Place: (_) => de_RouteFerryPlace(_, context),
        Time: __expectString,
    });
};
const de_RouteFerryDeparture = (output, context) => {
    return take(output, {
        Place: (_) => de_RouteFerryPlace(_, context),
        Time: __expectString,
    });
};
const de_RouteFerryLegDetails = (output, context) => {
    return take(output, {
        AfterTravelSteps: _json,
        Arrival: (_) => de_RouteFerryArrival(_, context),
        BeforeTravelSteps: _json,
        Departure: (_) => de_RouteFerryDeparture(_, context),
        Notices: _json,
        PassThroughWaypoints: (_) => de_RoutePassThroughWaypointList(_, context),
        RouteName: __expectString,
        Spans: _json,
        Summary: _json,
        TravelSteps: _json,
    });
};
const de_RouteFerryPlace = (output, context) => {
    return take(output, {
        Name: __expectString,
        OriginalPosition: (_) => de_Position23(_, context),
        Position: (_) => de_Position23(_, context),
        WaypointIndex: __expectInt32,
    });
};
const de_RouteKeepStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteLeg = (output, context) => {
    return take(output, {
        FerryLegDetails: (_) => de_RouteFerryLegDetails(_, context),
        Geometry: (_) => de_RouteLegGeometry(_, context),
        Language: __expectString,
        PedestrianLegDetails: (_) => de_RoutePedestrianLegDetails(_, context),
        TravelMode: __expectString,
        Type: __expectString,
        VehicleLegDetails: (_) => de_RouteVehicleLegDetails(_, context),
    });
};
const de_RouteLegGeometry = (output, context) => {
    return take(output, {
        LineString: (_) => de_LineString(_, context),
        Polyline: __expectString,
    });
};
const de_RouteLegList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteLeg(entry, context);
    });
    return retVal;
};
const de_RouteList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Route(entry, context);
    });
    return retVal;
};
const de_RouteMatrixBoundary = (output, context) => {
    return take(output, {
        Geometry: (_) => de_RouteMatrixBoundaryGeometry(_, context),
        Unbounded: __expectBoolean,
    });
};
const de_RouteMatrixBoundaryGeometry = (output, context) => {
    return take(output, {
        AutoCircle: _json,
        BoundingBox: (_) => de_BoundingBox(_, context),
        Circle: (_) => de_Circle(_, context),
        Polygon: (_) => de_LinearRings(_, context),
    });
};
const de_RoutePassThroughPlace = (output, context) => {
    return take(output, {
        OriginalPosition: (_) => de_Position23(_, context),
        Position: (_) => de_Position23(_, context),
        WaypointIndex: __expectInt32,
    });
};
const de_RoutePassThroughWaypoint = (output, context) => {
    return take(output, {
        GeometryOffset: __expectInt32,
        Place: (_) => de_RoutePassThroughPlace(_, context),
    });
};
const de_RoutePassThroughWaypointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoutePassThroughWaypoint(entry, context);
    });
    return retVal;
};
const de_RoutePedestrianArrival = (output, context) => {
    return take(output, {
        Place: (_) => de_RoutePedestrianPlace(_, context),
        Time: __expectString,
    });
};
const de_RoutePedestrianDeparture = (output, context) => {
    return take(output, {
        Place: (_) => de_RoutePedestrianPlace(_, context),
        Time: __expectString,
    });
};
const de_RoutePedestrianLegDetails = (output, context) => {
    return take(output, {
        Arrival: (_) => de_RoutePedestrianArrival(_, context),
        Departure: (_) => de_RoutePedestrianDeparture(_, context),
        Notices: _json,
        PassThroughWaypoints: (_) => de_RoutePassThroughWaypointList(_, context),
        Spans: (_) => de_RoutePedestrianSpanList(_, context),
        Summary: _json,
        TravelSteps: (_) => de_RoutePedestrianTravelStepList(_, context),
    });
};
const de_RoutePedestrianPlace = (output, context) => {
    return take(output, {
        Name: __expectString,
        OriginalPosition: (_) => de_Position23(_, context),
        Position: (_) => de_Position23(_, context),
        SideOfStreet: __expectString,
        WaypointIndex: __expectInt32,
    });
};
const de_RoutePedestrianSpan = (output, context) => {
    return take(output, {
        BestCaseDuration: __expectLong,
        Country: __expectString,
        Distance: __expectLong,
        Duration: __expectLong,
        DynamicSpeed: (_) => de_RouteSpanDynamicSpeedDetails(_, context),
        FunctionalClassification: __expectInt32,
        GeometryOffset: __expectInt32,
        Incidents: _json,
        Names: _json,
        PedestrianAccess: _json,
        Region: __expectString,
        RoadAttributes: _json,
        RouteNumbers: _json,
        SpeedLimit: (_) => de_RouteSpanSpeedLimitDetails(_, context),
        TypicalDuration: __expectLong,
    });
};
const de_RoutePedestrianSpanList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoutePedestrianSpan(entry, context);
    });
    return retVal;
};
const de_RoutePedestrianTravelStep = (output, context) => {
    return take(output, {
        ContinueStepDetails: _json,
        CurrentRoad: _json,
        Distance: __expectLong,
        Duration: __expectLong,
        ExitNumber: _json,
        GeometryOffset: __expectInt32,
        Instruction: __expectString,
        KeepStepDetails: (_) => de_RouteKeepStepDetails(_, context),
        NextRoad: _json,
        RoundaboutEnterStepDetails: (_) => de_RouteRoundaboutEnterStepDetails(_, context),
        RoundaboutExitStepDetails: (_) => de_RouteRoundaboutExitStepDetails(_, context),
        RoundaboutPassStepDetails: (_) => de_RouteRoundaboutPassStepDetails(_, context),
        Signpost: _json,
        TurnStepDetails: (_) => de_RouteTurnStepDetails(_, context),
        Type: __expectString,
    });
};
const de_RoutePedestrianTravelStepList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoutePedestrianTravelStep(entry, context);
    });
    return retVal;
};
const de_RouteRampStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteRoundaboutEnterStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteRoundaboutExitStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        RelativeExit: __expectInt32,
        RoundaboutAngle: __limitedParseDouble,
        SteeringDirection: __expectString,
    });
};
const de_RouteRoundaboutPassStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteSpanDynamicSpeedDetails = (output, context) => {
    return take(output, {
        BestCaseSpeed: __limitedParseDouble,
        TurnDuration: __expectLong,
        TypicalSpeed: __limitedParseDouble,
    });
};
const de_RouteSpanSpeedLimitDetails = (output, context) => {
    return take(output, {
        MaxSpeed: __limitedParseDouble,
        Unlimited: __expectBoolean,
    });
};
const de_RouteSummary = (output, context) => {
    return take(output, {
        Distance: __expectLong,
        Duration: __expectLong,
        Tolls: (_) => de_RouteTollSummary(_, context),
    });
};
const de_RouteToll = (output, context) => {
    return take(output, {
        Country: __expectString,
        PaymentSites: (_) => de_RouteTollPaymentSiteList(_, context),
        Rates: (_) => de_RouteTollRateList(_, context),
        Systems: _json,
    });
};
const de_RouteTollList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteToll(entry, context);
    });
    return retVal;
};
const de_RouteTollPaymentSite = (output, context) => {
    return take(output, {
        Name: __expectString,
        Position: (_) => de_Position23(_, context),
    });
};
const de_RouteTollPaymentSiteList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteTollPaymentSite(entry, context);
    });
    return retVal;
};
const de_RouteTollPrice = (output, context) => {
    return take(output, {
        Currency: __expectString,
        Estimate: __expectBoolean,
        PerDuration: __expectLong,
        Range: __expectBoolean,
        RangeValue: (_) => de_RouteTollPriceValueRange(_, context),
        Value: __limitedParseDouble,
    });
};
const de_RouteTollPriceSummary = (output, context) => {
    return take(output, {
        Currency: __expectString,
        Estimate: __expectBoolean,
        Range: __expectBoolean,
        RangeValue: (_) => de_RouteTollPriceValueRange(_, context),
        Value: __limitedParseDouble,
    });
};
const de_RouteTollPriceValueRange = (output, context) => {
    return take(output, {
        Max: __limitedParseDouble,
        Min: __limitedParseDouble,
    });
};
const de_RouteTollRate = (output, context) => {
    return take(output, {
        ApplicableTimes: __expectString,
        ConvertedPrice: (_) => de_RouteTollPrice(_, context),
        Id: __expectString,
        LocalPrice: (_) => de_RouteTollPrice(_, context),
        Name: __expectString,
        Pass: _json,
        PaymentMethods: _json,
        Transponders: _json,
    });
};
const de_RouteTollRateList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteTollRate(entry, context);
    });
    return retVal;
};
const de_RouteTollSummary = (output, context) => {
    return take(output, {
        Total: (_) => de_RouteTollPriceSummary(_, context),
    });
};
const de_RouteTurnStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteUTurnStepDetails = (output, context) => {
    return take(output, {
        Intersection: _json,
        SteeringDirection: __expectString,
        TurnAngle: __limitedParseDouble,
        TurnIntensity: __expectString,
    });
};
const de_RouteVehicleArrival = (output, context) => {
    return take(output, {
        Place: (_) => de_RouteVehiclePlace(_, context),
        Time: __expectString,
    });
};
const de_RouteVehicleDeparture = (output, context) => {
    return take(output, {
        Place: (_) => de_RouteVehiclePlace(_, context),
        Time: __expectString,
    });
};
const de_RouteVehicleLegDetails = (output, context) => {
    return take(output, {
        Arrival: (_) => de_RouteVehicleArrival(_, context),
        Departure: (_) => de_RouteVehicleDeparture(_, context),
        Incidents: _json,
        Notices: _json,
        PassThroughWaypoints: (_) => de_RoutePassThroughWaypointList(_, context),
        Spans: (_) => de_RouteVehicleSpanList(_, context),
        Summary: _json,
        TollSystems: _json,
        Tolls: (_) => de_RouteTollList(_, context),
        TravelSteps: (_) => de_RouteVehicleTravelStepList(_, context),
        TruckRoadTypes: _json,
        Zones: _json,
    });
};
const de_RouteVehiclePlace = (output, context) => {
    return take(output, {
        Name: __expectString,
        OriginalPosition: (_) => de_Position23(_, context),
        Position: (_) => de_Position23(_, context),
        SideOfStreet: __expectString,
        WaypointIndex: __expectInt32,
    });
};
const de_RouteVehicleSpan = (output, context) => {
    return take(output, {
        BestCaseDuration: __expectLong,
        CarAccess: _json,
        Country: __expectString,
        Distance: __expectLong,
        Duration: __expectLong,
        DynamicSpeed: (_) => de_RouteSpanDynamicSpeedDetails(_, context),
        FunctionalClassification: __expectInt32,
        Gate: __expectString,
        GeometryOffset: __expectInt32,
        Incidents: _json,
        Names: _json,
        Notices: _json,
        RailwayCrossing: __expectString,
        Region: __expectString,
        RoadAttributes: _json,
        RouteNumbers: _json,
        ScooterAccess: _json,
        SpeedLimit: (_) => de_RouteSpanSpeedLimitDetails(_, context),
        TollSystems: _json,
        TruckAccess: _json,
        TruckRoadTypes: _json,
        TypicalDuration: __expectLong,
        Zones: _json,
    });
};
const de_RouteVehicleSpanList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteVehicleSpan(entry, context);
    });
    return retVal;
};
const de_RouteVehicleTravelStep = (output, context) => {
    return take(output, {
        ContinueHighwayStepDetails: (_) => de_RouteContinueHighwayStepDetails(_, context),
        ContinueStepDetails: _json,
        CurrentRoad: _json,
        Distance: __expectLong,
        Duration: __expectLong,
        EnterHighwayStepDetails: (_) => de_RouteEnterHighwayStepDetails(_, context),
        ExitNumber: _json,
        ExitStepDetails: (_) => de_RouteExitStepDetails(_, context),
        GeometryOffset: __expectInt32,
        Instruction: __expectString,
        KeepStepDetails: (_) => de_RouteKeepStepDetails(_, context),
        NextRoad: _json,
        RampStepDetails: (_) => de_RouteRampStepDetails(_, context),
        RoundaboutEnterStepDetails: (_) => de_RouteRoundaboutEnterStepDetails(_, context),
        RoundaboutExitStepDetails: (_) => de_RouteRoundaboutExitStepDetails(_, context),
        RoundaboutPassStepDetails: (_) => de_RouteRoundaboutPassStepDetails(_, context),
        Signpost: _json,
        TurnStepDetails: (_) => de_RouteTurnStepDetails(_, context),
        Type: __expectString,
        UTurnStepDetails: (_) => de_RouteUTurnStepDetails(_, context),
    });
};
const de_RouteVehicleTravelStepList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RouteVehicleTravelStep(entry, context);
    });
    return retVal;
};
const de_ValidationExceptionField = (output, context) => {
    return take(output, {
        Message: [, __expectString, `message`],
        Name: [, __expectString, `name`],
    });
};
const de_ValidationExceptionFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ValidationExceptionField(entry, context);
    });
    return retVal;
};
const de_WaypointOptimizationImpedingWaypoint = (output, context) => {
    return take(output, {
        FailedConstraints: _json,
        Id: __expectString,
        Position: (_) => de_Position(_, context),
    });
};
const de_WaypointOptimizationImpedingWaypointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_WaypointOptimizationImpedingWaypoint(entry, context);
    });
    return retVal;
};
const de_WaypointOptimizationOptimizedWaypoint = (output, context) => {
    return take(output, {
        ArrivalTime: __expectString,
        ClusterIndex: __expectInt32,
        DepartureTime: __expectString,
        Id: __expectString,
        Position: (_) => de_Position(_, context),
    });
};
const de_WaypointOptimizationOptimizedWaypointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_WaypointOptimizationOptimizedWaypoint(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const _K = "Key";
const _PB = "PricingBucket";
const _k = "key";
const _xagpb = "x-amz-geo-pricing-bucket";
